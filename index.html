<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Algorithms in Python</title>

    <!-- Prism.js for syntax highlighting -->
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>

    <style>
      body {
        font-family: Arial, sans-serif;
        line-height: 1.6;
        background-color: #f4f4f4;
        padding: 20px;
        max-width: 800px;
        margin: auto;
      }
      h2 {
        color: #333;
        border-bottom: 2px solid #666;
        padding-bottom: 5px;
      }
      p {
        color: #222;
        font-size: 16px;
      }
      .complexity {
        background: #222;
        color: #fff;
        padding: 8px;
        display: inline-block;
        border-radius: 5px;
        font-size: 14px;
        margin: 5px 0;
      }
    </style>
  </head>
  <body>
    <h2>ðŸ”· Linear Search</h2>
    <p>
      Linear search iterates through the list sequentially to find the target
      element. It works well for small datasets but is inefficient for large
      lists.
    </p>
    <p class="complexity">Time Complexity:</p>
    <p class="complexity">O(n) (Worst & Average)</p>
    <p class="complexity">O(1) (Best - if found at start)</p>
    <pre><code class="language-python">
def lin_search(lst, item):
    for index in range(len(lst)):
        if lst[index] == item:
            print("Item found at index:", index)
            return
    print("Item not found")

    </code></pre>

    <h2>ðŸ”· Binary Search</h2>
    <p>
      Binary search is used on sorted lists. It repeatedly divides the list into
      halves and eliminates one half at each step.
    </p>
    <p class="complexity">Time Complexity:</p>
    <p class="complexity">O(log n) (Best, Average & Worst)</p>
    <pre><code class="language-python">
def bin_search(lst, item):
ub = len(lst) - 1
lb = 0

while lb <= ub:
    mid = (ub + lb) // 2
    if item < lst[mid]:
        ub = mid - 1
    elif item > lst[mid]:
        lb = mid + 1
    else:
        print("Item found at index:", mid)
        return

print("Item not found")
    
    </code></pre>

    <h2>ðŸ”· Insertion Sort</h2>
    <p>
      Insertion sort builds the sorted list one item at a time by inserting each
      element in its correct position.
    </p>
    <p class="complexity">Time Complexity:</p>
    <p class="complexity">O(nÂ²) (Worst & Average)</p>
    <p class="complexity">O(n) (Best - already sorted)</p>
    <pre><code class="language-python">
def ins_sort(lst):
    for i in range(1, len(lst)):
        key = lst[i]
        j = i - 1
        while j >= 0 and key < lst[j]:
            lst[j + 1] = lst[j]
            j -= 1
        lst[j + 1] = key
    print(lst)
    </code></pre>

    <h2>ðŸ”· Bubble Sort</h2>
    <p>
      Bubble sort repeatedly swaps adjacent elements if they are in the wrong
      order.
    </p>
    <p class="complexity">Time Complexity:</p>
    <p class="complexity">O(nÂ²) (Worst & Average)</p>
    <p class="complexity">O(n) (Best - already sorted)</p>
    <pre><code class="language-python">
def bub_sort(lst):
    ub = len(lst)
    swap = True
    while swap and ub != 0:
        swap = False
        for i in range(ub - 1):
            if lst[i] > lst[i + 1]:  # Ascending order
                lst[i], lst[i + 1] = lst[i + 1], lst[i]
                swap = True
    print(lst)
    </code></pre>

    <h2>ðŸ”· Stack (Using List)</h2>
    <p>
      A stack follows LIFO (Last In, First Out). We can push and pop elements.
    </p>
    <p class="complexity">Push & Pop: O(1)</p>
    <pre><code class="language-python">
class Stack:
    def __init__(self):
        self.stack = []

    def push(self, item):
        self.stack.append(item)

    def pop(self):
        if not self.is_empty():
            return self.stack.pop()
        return None

    def is_empty(self):
        return len(self.stack) == 0
    </code></pre>

    <h2>ðŸ”· Queue (Using List)</h2>
    <p>
      A queue follows FIFO (First In, First Out). We enqueue (insert) at the
      back and dequeue (remove) from the front.
    </p>
    <p class="complexity">Enqueue & Dequeue: O(1)</p>
    <pre><code class="language-python">
class Queue:
    def __init__(self):
        self.queue = []

    def enqueue(self, item):
        self.queue.append(item)

    def dequeue(self):
        if not self.is_empty():
            return self.queue.pop(0)
        return None

    def is_empty(self):
        return len(self.queue) == 0
    </code></pre>

    <h2>ðŸ”· Linked List</h2>
    <p>
      A linked list consists of nodes where each node contains data and a
      reference to the next node.
    </p>
    <p class="complexity">Insertion & Deletion: O(1) at head</p>
    <p class="complexity">O(n) for search</p>
    <pre><code class="language-python">
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class LinkedList:
    def __init__(self):
        self.head = None

    def insert(self, data):
        new_node = Node(data)
        new_node.next = self.head
        self.head = new_node

    def display(self):
        temp = self.head
        while temp:
            print(temp.data, end=" -> ")
            temp = temp.next
        print("None")
    </code></pre>

    <h2>ðŸ”· Binary Tree (Insert & Search)</h2>
    <p>
      A binary tree consists of nodes where each node has at most two children
      (left and right).
    </p>
    <p class="complexity">Insertion & Search: O(log n) (Balanced)</p>
    <p class="complexity">O(n) (Unbalanced)</p>
    <pre><code class="language-python">
class TreeNode:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None

def insert(root, value):
    if root is None:
        return TreeNode(value)
    if value < root.value:
        root.left = insert(root.left, value)
    else:
        root.right = insert(root.right, value)
    return root

def search(root, value):
    if root is None or root.value == value:
        return root
    if value < root.value:
        return search(root.left, value)
    return search(root.right, value)
    </code></pre>
  </body>
</html>
